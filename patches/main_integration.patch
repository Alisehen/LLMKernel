"""
main.py é›†æˆåˆ†ç±»ç³»ç»Ÿçš„å…·ä½“ä¿®æ”¹

åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ importsï¼Œç„¶åä¿®æ”¹run_one_taskå‡½æ•°
"""

# ==================== 1. åœ¨æ–‡ä»¶å¼€å¤´æ·»åŠ import ====================
# åœ¨ main.py ç¬¬24è¡Œä¹‹åæ·»åŠ ï¼š

from config.operator_categories_v2 import (
    classify_operator,
    OPERATOR_CATEGORIES,
    build_stage_prompt_section,
    get_key_ncu_metrics,
    check_early_exit,
    should_skip_stage,
)


# ==================== 2. åœ¨run_one_taskå‡½æ•°å¼€å¤´æ·»åŠ åˆ†ç±»é€»è¾‘ ====================
# åœ¨ run_one_task å‡½æ•°çš„å¼€å¤´ï¼ˆå¤§çº¦ç¬¬550è¡Œé™„è¿‘ï¼‰ï¼Œåœ¨åˆ›å»ºè¾“å‡ºç›®å½•ä¹‹åæ·»åŠ ï¼š

def run_one_task(task_path: Path, args, call_llm):
    """Run optimization for a single task."""
    # ... åŸæœ‰çš„è¾“å‡ºç›®å½•åˆ›å»ºä»£ç  ...

    # ===== ã€æ–°å¢ã€‘ç®—å­åˆ†ç±» =====
    task_name = task_path.stem  # ä¾‹å¦‚: "56_Matmul_Sigmoid_Sum"
    level = "level2" if "/level2/" in str(task_path) else "level1"

    category = classify_operator(task_name, level)
    category_config = OPERATOR_CATEGORIES[category]

    print(f"\n{'='*80}")
    print(f"ğŸ“‚ Operator Category: {category}")
    print(f"   Description: {category_config['description']}")
    print(f"   Total Stages: {len(category_config['stages'])}")
    if category_config.get('early_exit_enabled'):
        print(f"   Early Exit: Enabled")
    print(f"{'='*80}\n")

    # ä¿å­˜åˆ†ç±»ä¿¡æ¯åˆ°metadata
    category_metadata = {
        "category": category,
        "level": level,
        "task_name": task_name,
        "num_stages": len(category_config['stages']),
        "early_exit_enabled": category_config.get('early_exit_enabled', False),
    }
    (root_dir / "category_metadata.json").write_text(
        json.dumps(category_metadata, indent=2)
    )

    # ... ç»§ç»­åŸæœ‰çš„seedé˜¶æ®µä»£ç  ...


# ==================== 3. æ›¿æ¢ç¡¬ç¼–ç çš„OPTIMIZATION_STAGES ====================
# æ‰¾åˆ° "for stage_idx in range(len(OPTIMIZATION_STAGES)):" è¿™ä¸€è¡Œï¼ˆå¤§çº¦ç¬¬773è¡Œï¼‰
# æ›¿æ¢ä¸ºï¼š

    # ===== ã€ä¿®æ”¹ã€‘ä½¿ç”¨åˆ†ç±»ç‰¹å®šçš„stages =====
    optimization_stages = category_config["stages"]

    print(f"\n{'='*80}")
    print(f"Starting Multi-Stage Optimization ({len(optimization_stages)} stages)")
    print(f"Category: {category}")
    print(f"{'='*80}\n")

    for stage_idx, stage_config in enumerate(optimization_stages):
        stage_name = stage_config["name"]
        stage_description = stage_config["description"]
        stage_focus = stage_config["focus"]

        print(f"\n{'='*80}")
        print(f"[Stage {stage_idx + 1}/{len(optimization_stages)}] {stage_description}")
        print(f"Stage Name: {stage_name}")
        print(f"Focus: {stage_focus}")
        print(f"{'='*80}")

        # ===== ã€æ–°å¢ã€‘Early Exitæ£€æŸ¥ =====
        # æå–kernel_sizeï¼ˆå¦‚æœæ˜¯Convç±»ç®—å­ï¼‰
        op_metadata = {
            "op_type": task_name.lower(),
            "score": best_score,
        }

        # å°è¯•ä»task_pathä¸­æå–kernel_size
        try:
            task_code = task_path.read_text()
            import re
            ks_match = re.search(r'kernel_size\s*=\s*(\d+)', task_code)
            if ks_match:
                op_metadata["kernel_size"] = int(ks_match.group(1))
        except:
            pass

        should_exit, exit_reason = check_early_exit(
            category=category,
            stage_id=stage_idx,
            performance_score=best_score,
            op_metadata=op_metadata,
        )

        if should_exit:
            print(f"\nâ›” {'='*70}")
            print(f"â›” EARLY EXIT TRIGGERED")
            print(f"â›” Reason: {exit_reason}")
            print(f"â›” Current best score: {best_score:.4f}")
            print(f"â›” Skipping remaining stages and using current best kernel.")
            print(f"â›” {'='*70}\n")
            break

        # ===== ç»§ç»­åŸæœ‰çš„NCU profilingä»£ç  =====
        # ... (ä¿æŒä¸å˜) ...


# ==================== 4. ä¿®æ”¹NCU metricsæå–éƒ¨åˆ† ====================
# åœ¨ NCU profiling åï¼ˆå¤§çº¦ç¬¬824è¡Œï¼‰ï¼Œæ·»åŠ å…³é”®æŒ‡æ ‡è¿‡æ»¤ï¼š

        # ... profile_bench å’Œ load_ncu_metrics ä»£ç ä¿æŒä¸å˜ ...
        metrics_df = load_ncu_metrics(csv_path, extra_keep=("Kernel Name",),
                                      name_list=kernel_names, select="last")

        # ===== ã€æ–°å¢ã€‘åªæå–å…³é”®æŒ‡æ ‡ =====
        key_metrics = get_key_ncu_metrics(category, stage_idx)

        print(f"\nğŸ“Š Key Metrics for {stage_name}:")
        for metric_name, ncu_metric in key_metrics.items():
            print(f"   â€¢ {metric_name}: {ncu_metric}")

        # è¿‡æ»¤metrics_dfï¼Œåªä¿ç•™å…³é”®æŒ‡æ ‡
        if not metrics_df.empty:
            filtered_df = metrics_df[
                metrics_df["Metric Name"].isin(key_metrics.values())
            ].copy()

            if filtered_df.empty:
                print(f"âš ï¸  Warning: No key metrics found, using all metrics")
                filtered_df = metrics_df
            else:
                print(f"   Filtered: {len(metrics_df)} â†’ {len(filtered_df)} metrics")

            metrics_block = metrics_to_prompt(filtered_df)
        else:
            metrics_block = "No NCU metrics available"

        # ===== ã€æ–°å¢ã€‘Skip Stageæ£€æŸ¥ =====
        should_skip, skip_reason = should_skip_stage(
            category=category,
            stage_id=stage_idx,
            op_metadata=op_metadata,
        )

        if should_skip:
            print(f"\nâ© {'='*70}")
            print(f"â© STAGE SKIPPED")
            print(f"â© Reason: {skip_reason}")
            print(f"â© Proceeding to next stage...")
            print(f"â© {'='*70}\n")
            continue

        # ===== ã€ä¿®æ”¹ã€‘è°ƒç”¨build_optimization_promptæ—¶ä¼ å…¥category =====
        opt_prompt = build_optimization_prompt(
            arch_path=best_kernel.code_path,
            gpu_name=args.gpu,
            ncu_metrics=metrics_block,
            history_block=None,
            stage_name=stage_name,
            stage_description=stage_description,
            failure_analysis="",
            # ã€æ–°å¢ã€‘ä¼ å…¥åˆ†ç±»ä¿¡æ¯
            category=category,
            stage_id=stage_idx,
        )

        # ... åç»­çš„LLMè°ƒç”¨å’Œbenchmarkä»£ç ä¿æŒä¸å˜ ...


# ==================== 5. åœ¨æœ€åè¾“å‡ºæ—¶æ·»åŠ åˆ†ç±»ä¿¡æ¯ ====================
# åœ¨å‡½æ•°ç»“æŸå‰ï¼ˆreturnä¹‹å‰ï¼‰æ·»åŠ ï¼š

    # ===== è¾“å‡ºæœ€ç»ˆç»“æœ =====
    print(f"\n{'='*80}")
    print(f"ğŸ Optimization Complete")
    print(f"   Category: {category}")
    print(f"   Stages Executed: {len(optimization_stages)}")
    print(f"   Final Best Score: {best_score:.4f}")
    print(f"{'='*80}\n")

    return {
        "best_kernel": best_kernel,
        "best_score": best_score,
        "category": category,
        "stages_executed": len(optimization_stages),
    }
