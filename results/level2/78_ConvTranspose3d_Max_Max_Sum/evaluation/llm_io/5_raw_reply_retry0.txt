```python
import torch
import torch.nn as nn
import triton
import triton.language as tl


@triton.jit
def fused_double_maxpool_sum_kernel(
    x_ptr,
    out_ptr,
    # Tensor dimensions
    N, C, D, H, W,
    # Strides for input
    stride_n, stride_c, stride_d, stride_h, stride_w,
    # Output dimensions after both pools
    D_out, H_out, W_out,
    BLOCK_C: tl.constexpr,
    BLOCK_SIZE: tl.constexpr,
):
    """
    Optimized fused kernel for:
    1. MaxPool3d(kernel_size=2) -> reduces dimensions by factor of 2
    2. MaxPool3d(kernel_size=3) -> reduces dimensions by factor of 3
    3. Sum over channels (dim=1) with keepdim=True
    
    Key optimizations:
    - Direct 6x6x6 max computation without intermediate stores
    - Vectorized channel block processing
    - Precomputed pointer offsets for better memory coalescing
    - Reduced conditional branching
    """
    # Program IDs
    pid_n = tl.program_id(0)
    pid_spatial = tl.program_id(1)
    
    # Batch index
    n_idx = pid_n
    if n_idx >= N:
        return
    
    # Spatial block indices
    block_d = (pid_spatial // (H_out * W_out // BLOCK_SIZE)) * BLOCK_SIZE
    block_hw = (pid_spatial % (H_out * W_out // BLOCK_SIZE)) * BLOCK_SIZE
    
    d2_idx = block_d + tl.arange(0, BLOCK_SIZE) // (W_out * H_out)
    h2_idx = (block_hw + tl.arange(0, BLOCK_SIZE)) // W_out % H_out
    w2_idx = (block_hw + tl.arange(0, BLOCK_SIZE)) % W_out
    
    # Create spatial mask
    spatial_mask = (d2_idx < D_out) & (h2_idx < H_out) & (w2_idx < W_out)
    
    # Check if any spatial position is valid using sum > 0
    if tl.sum(spatial_mask) == 0:
        return
    
    # Channel offsets for this block
    c_offsets = tl.arange(0, BLOCK_C)
    c_mask = c_offsets < C
    
    # Initialize accumulators for each spatial position in the block
    max_acc = tl.full((BLOCK_SIZE, BLOCK_C), float('-inf'), dtype=tl.float32)
    
    # Precompute base offsets for input tensor
    n_base = n_idx * stride_n
    
    # Unroll the 6x6x6 window processing
    # This reduces loop overhead and enables better instruction scheduling
    for kd in range(6):
        d_start = d2_idx * 6 + kd
        d_valid = d_start < D
        
        for kh in range(6):
            h_start = h2_idx * 6 + kh
            h_valid = h_start < H
            
            for kw in range(6):
                w_start = w2_idx * 6 + kw
                w_valid = w_start < W
                
                # Combine all spatial validity checks
                valid_mask = spatial_mask & d_valid & h_valid & w_valid
                
                # Check if any position is valid using sum > 0
                if tl.sum(valid_mask) > 0:
                    # Compute pointer offsets for valid positions
                    for i in tl.range(BLOCK_SIZE):
                        if valid_mask[i]:
                            offset = (n_base + 
                                    d_start[i] * stride_d + 
                                    h_start[i] * stride_h + 
                                    w_start[i] * stride_w)
                            
                            # Load values for all channels in the block
                            vals = tl.load(x_ptr + offset + c_offsets * stride_c, 
                                          mask=c_mask, other=float('-inf'))
                            
                            # Update max for this spatial position
                            max_acc = tl.where(
                                c_mask[None, :] & (vals > max_acc[i, :]),
                                vals,
                                max_acc
                            )
    
    # Sum over channels (dim=1) with keepdim=True
    channel_sum = tl.sum(max_acc, axis=1)
    
    # Store results for valid spatial positions
    for i in tl.range(BLOCK_SIZE):
        if spatial_mask[i]:
            out_idx = (n_idx * D_out * H_out * W_out + 
                      d2_idx[i] * H_out * W_out + 
                      h2_idx[i] * W_out + 
                      w2_idx[i])
            tl.store(out_ptr + out_idx, channel_sum[i])


def fused_double_maxpool_sum(x: torch.Tensor) -> torch.Tensor:
    """
    Optimized fused implementation of:
    1. MaxPool3d(kernel_size=2)
    2. MaxPool3d(kernel_size=3)
    3. Sum over channels (dim=1) with keepdim=True
    """
    N, C, D, H, W = x.shape
    
    # Output dimensions after both pools
    D_out = D // 6
    H_out = H // 6
    W_out = W // 6
    
    # Create output tensor [N, 1, D_out, H_out, W_out]
    out = torch.empty((N, 1, D_out, H_out, W_out),
                      device=x.device, dtype=x.dtype)
    
    # Choose optimal block sizes
    BLOCK_C = min(triton.next_power_of_2(C), 128)  # Limit to 128 for register pressure
    BLOCK_SIZE = 8  # Optimal for Ada Lovelace memory pattern
    
    # Calculate grid size
    grid_n = N
    grid_spatial = (D_out * H_out * W_out + BLOCK_SIZE - 1) // BLOCK_SIZE
    
    # Launch kernel with optimized configuration
    fused_double_maxpool_sum_kernel[(grid_n, grid_spatial)](
        x,
        out,
        N, C, D, H, W,
        x.stride(0), x.stride(1), x.stride(2), x.stride(3), x.stride(4),
        D_out, H_out, W_out,
        BLOCK_C=BLOCK_C,
        BLOCK_SIZE=BLOCK_SIZE,
        num_stages=2,  # Optimized for memory-bound operation
        num_warps=4,   # Balanced for occupancy
    )
    
    return out


class ModelNew(nn.Module):
    """
    Model that performs a 3D transposed convolution, followed by two max pooling layers and a sum operation.
    ConvTranspose3d is kept in PyTorch native, only the pooling and sum operations are fused in Triton.
    """
    def __init__(self, in_channels, out_channels, kernel_size, stride, padding):
        super(ModelNew, self).__init__()
        # Keep ConvTranspose3d as PyTorch native - DO NOT reimplement in Triton
        self.conv_transpose = nn.ConvTranspose3d(
            in_channels, out_channels, kernel_size,
            stride=stride, padding=padding
        )
    
    def forward(self, x):
        # Step 1: PyTorch native ConvTranspose3d
        x = self.conv_transpose(x)
        
        # Step 2: Optimized fused double maxpool + sum in Triton
        x = fused_double_maxpool_sum(x)
        
        return x
```