You are a Triton kernel optimization specialist. Generate the FASTEST possible kernel.

# Target GPU
GPU Name: 4090
Architecture: Ada Lovelace
• Compute Capability: 8.9
• Number of SMs: 128
• Memory Bandwidth: 1008 GB/s
• TF32 Tensor Core TFLOPS: 82.6 with dense
• BFLOAT16 Tensor Core TFLOPS: 165.2 with dense
• FP16 Tensor Core TFLOPS: 165.2 with dense
• Maximum number of registers per thread: 255
• Maximum threads per block: 1024
• Maximum threads per SM: 1536
• Warp size: 32
• Maximum concurrent warps per SM: 48
• Shared memory capacity per SM: 100 KB
• Maximum shared memory per thread block: 99 KB
• L2 cache (global, all SM shared): 72 MB

[OPTIMIZATION STAGE]

## Current Optimization Stage

Focus: Memory pattern for fused operations.

Key Principle:
- Fusion benefit = eliminated INTERMEDIATE stores
- Multiple input loads are OK; intermediate stores are NOT

Rules:
- ✅ Multiple tl.load() for different inputs (x, weight, bias) - OK
- ❌ tl.store() for intermediate results - NEVER (this is what fusion eliminates)
- ✅ Single tl.store() for final output - required

Verification:
- Count tl.store() calls: should equal number of OUTPUT tensors (usually 1)
- Intermediate values: must stay in registers between ops
- If you see store-then-load pattern for same data → BUG, refactor

Multi-input Fusion Pattern:
```
x = tl.load(input_ptr + offs, mask=mask)
w = tl.load(weight_ptr + ..., mask=...)  # OK: different input
b = tl.load(bias_ptr + ..., mask=...)    # OK: different input
y = op1(x, w)  # in registers
z = op2(y, b)  # in registers
tl.store(out_ptr + offs, z, mask=mask)   # single output store
```

num_stages: start with 2, only increase if memory stalls high AND registers OK



[CURRENT CODE]
```python
import math
import torch
import torch.nn as nn
import triton
import triton.language as tl


@triton.jit
def add_layernorm_lastdim_kernel(
    x_ptr,            # [rows * width]
    ln_weight_ptr,    # [width]
    ln_bias_ptr,      # [width]
    sum_weight_ptr,   # scalar parameter
    out_ptr,          # [rows * width]
    rows,             # number of rows
    width,            # normalization dimension size (flattened last dims)
    inv_width,        # 1.0 / width (float)
    eps,              # layernorm epsilon (float)
    BLOCK_W: tl.constexpr,
):
    pid = tl.program_id(0)
    offs_w = tl.arange(0, BLOCK_W)

    # Compute base index for this row in the flattened [rows, width] layout
    row_start = pid * width
    ptrs = x_ptr + row_start + offs_w

    # Masks
    row_mask = pid < rows
    col_mask = offs_w < width
    mask = row_mask & col_mask

    # Load input row
    x = tl.load(ptrs, mask=mask, other=0.0)

    # Load scalar sum_weight and add
    sum_weight = tl.load(sum_weight_ptr)
    x = x + sum_weight

    # Compute mean/var in fp32 for stability over the width dimension
    x_f32 = x.to(tl.float32)
    mean = tl.sum(x_f32, axis=0) * inv_width
    diff = x_f32 - mean
    var = tl.sum(diff * diff, axis=0) * inv_width
    inv_std = tl.rsqrt(var + eps)

    # Load LayerNorm affine parameters (flattened over normalized dims)
    gamma = tl.load(ln_weight_ptr + offs_w, mask=col_mask, other=1.0)
    beta = tl.load(ln_bias_ptr + offs_w, mask=col_mask, other=0.0)
    gamma = gamma.to(tl.float32)
    beta = beta.to(tl.float32)

    # Normalize and apply affine
    y = diff * inv_std
    y = y * gamma + beta

    # Cast back to input dtype
    y = y.to(x.dtype)

    # Store result
    tl.store(out_ptr + row_start + offs_w, y, mask=mask)


def fused_add_layernorm_lastdim(x: torch.Tensor,
                                sum_weight: torch.Tensor,
                                ln_module: nn.LayerNorm) -> torch.Tensor:
    """
    Fused kernel: x = x + sum_weight; x = LayerNorm(x) over the same last
    dimension(s) as PyTorch nn.LayerNorm(normalized_shape=...).

    PyTorch reference:
        x = x + sum_weight
        x = ln_module(x)

    This implementation:
        - Flattens the last len(normalized_shape) dimensions into a single
          width dimension.
        - Runs a Triton kernel that normalizes along this width dimension.
        - Reshapes the result back to the original shape.

    This guarantees that the reduction axes match PyTorch LayerNorm exactly.
    """
    assert x.is_contiguous(), "Input x must be contiguous"
    orig_shape = x.shape
    x_dim = x.dim()

    normalized_shape = tuple(ln_module.normalized_shape)
    norm_ndim = len(normalized_shape)
    assert norm_ndim >= 1, "normalized_shape must have at least one dimension"
    assert x_dim >= norm_ndim, (
        f"Input rank {x_dim} is smaller than normalized_shape rank {norm_ndim}"
    )
    assert tuple(orig_shape[-norm_ndim:]) == normalized_shape, (
        f"Input trailing shape {tuple(orig_shape[-norm_ndim:])} "
        f"does not match LayerNorm normalized_shape {normalized_shape}"
    )

    # Flatten trailing normalized dimensions into a single width dimension
    width = math.prod(normalized_shape)
    rows = x.numel() // width

    x_2d = x.view(rows, width)
    out_2d = torch.empty_like(x_2d)

    # Flatten LayerNorm affine parameters to match flattened normalized dims
    ln_weight = ln_module.weight.view(-1)
    ln_bias = ln_module.bias.view(-1)
    assert ln_weight.numel() == width and ln_bias.numel() == width, (
        "Flattened LayerNorm weight/bias must have size equal to "
        "the product of normalized_shape"
    )
    eps = ln_module.eps

    # Choose BLOCK_W as next power-of-two >= width, up to a reasonable maximum
    MAX_BLOCK_W = 1024
    BLOCK_W = 1 << (width - 1).bit_length()
    if BLOCK_W > MAX_BLOCK_W:
        raise ValueError(
            f"Normalized dimension size {width} exceeds maximum supported BLOCK_W={MAX_BLOCK_W}; "
            f"got width={width}."
        )

    inv_width = 1.0 / float(width)

    grid = lambda META: (rows,)

    # Heuristic for warps: more threads for wider vectors
    num_warps = 4 if BLOCK_W <= 128 else 8

    add_layernorm_lastdim_kernel[grid](
        x_2d,
        ln_weight,
        ln_bias,
        sum_weight,
        out_2d,
        rows,
        width,
        inv_width,
        eps,
        BLOCK_W=BLOCK_W,
        num_warps=num_warps,
    )

    out = out_2d.view(orig_shape)
    return out


class ModelNew(nn.Module):
    """
    Model that performs a 3D transposed convolution, followed by a fused
    (add scalar + LayerNorm over the last normalized_shape dims), then
    average pooling and GELU.

    The fused Triton kernel replaces:
        x = x + self.sum_weight
        x = self.norm(x)

    where self.norm is nn.LayerNorm(normalized_shape=norm_shape),
    i.e., normalization is along the last len(norm_shape) dimensions.
    """

    def __init__(self, in_channels, out_channels, kernel_size, stride,
                 padding, output_padding, sum_weight, norm_shape, pool_kernel_size):
        super(ModelNew, self).__init__()
        self.conv_transpose = nn.ConvTranspose3d(
            in_channels,
            out_channels,
            kernel_size,
            stride=stride,
            padding=padding,
            output_padding=output_padding,
        )

        # Scalar parameter for the sum
        self.sum_weight = nn.Parameter(torch.tensor(sum_weight))

        # LayerNorm as in the original model: norm over last normalized_shape dims
        self.norm = nn.LayerNorm(norm_shape)

        # Remaining PyTorch ops
        self.avg_pool = nn.AvgPool3d(kernel_size=pool_kernel_size)
        self.gelu = nn.GELU()

    def forward(self, x):
        # x: [N, C_in, D, H, W]
        x = self.conv_transpose(x)  # [N, C_out, D_out, H_out, W_out]

        # Fused: add scalar + LayerNorm over the last dims as defined by self.norm
        x = fused_add_layernorm_lastdim(x, self.sum_weight, self.norm)

        x = self.avg_pool(x)
        x = self.gelu(x)
        return x
```

[NCU PROFILING METRICS]
{
  "add_layernorm_lastdim_kernel": {
    "sm__throughput.avg.pct_of_peak_sustained_elapsed": 90.05,
    "launch__grid_size": 4194304,
    "sm__warps_active.avg.pct_of_peak_sustained_active": 84.85,
    "dram__throughput.avg.pct_of_peak_sustained_elapsed": 64.5,
    "lts__t_sector_hit_rate.pct": 50.03
  }
}

**Task**: Analyze the NCU metrics and current code, then generate optimized code that maximizes performance.

OUTPUT RULES (STRICT):
1. Follow this exact order:
   1. Imports: torch, torch.nn, triton, triton.language as tl
   2. @triton.jit decorated kernel function(s)
   3. Wrapper function(s) for grid calculation and kernel launch
   4. class ModelNew(nn.Module) that calls your kernels
2. Do NOT include: testing code, if __name__, get_inputs, get_init_inputs

```python
# <optimized Triton code>
```
