You are optimizing a Triton kernel based on algorithmic analysis.

# PyTorch Reference (Target Behavior)

```python
import torch
import torch.nn as nn

class Model(nn.Module):
    """
    Model that performs a matrix multiplication (Gemm), Batch Normalization, scaling, and Softmax.
    """
    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, scale_shape=(1,)):
        super(Model, self).__init__()
        self.gemm = nn.Linear(in_features, out_features)
        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)
        self.scale = nn.Parameter(torch.ones(scale_shape))
        self.softmax = nn.Softmax(dim=1)

    def forward(self, x):
        """
        Args:
            x (torch.Tensor): Input tensor of shape (batch_size, in_features).
        Returns:
            torch.Tensor: Output tensor of shape (batch_size, out_features).
        """
        x = self.gemm(x)
        x = self.bn(x)
        x = self.scale * x
        x = self.softmax(x)
        return x

batch_size = 1024
in_features = 8192
out_features = 8192
bn_eps = 1e-5
bn_momentum = 0.1
scale_shape = (1,)

def get_inputs():
    return [torch.rand(batch_size, in_features)]

def get_init_inputs():
    return [in_features, out_features, bn_eps, bn_momentum, scale_shape]
```

**CRITICAL**: Study the PyTorch code carefully to understand:
- What does `forward()` return? (full output sequence vs final hidden state only)
- What is the computational pattern?
- What are the input/output shapes?

Your optimized kernel MUST match this exact behavior.

---

# Analysis Results

**Bottleneck**: After the fused GEMM kernel writes its MxN output, PyTorch BatchNorm and the separate scaling op read and write the same MxN tensor again before the Triton softmax, so the pipeline is dominated by redundant global memory traffic and extra kernel launches rather than math.

**Optimization Strategy**: In inference/eval mode, fold BatchNorm and the separate scaling parameter into the linear layer by precomputing an equivalent fused weight and bias (BN is affine at inference), then run a single Triton GEMM that directly outputs the pre-normalized, scaled activations which can go straight into softmax.

**Implementation Plan**: In ModelNew.forward, when self.training is False, replace `gemm -> bn -> scale` with a single fused linear: compute per-output feature coefficients `alpha_j = (bn.weight[j] * scale) / sqrt(bn.running_var[j] + bn.eps)` and `beta_j = bn.bias[j] - alpha_j * bn.running_mean[j]`, then form `W_fused[j,:] = alpha_j * W[j,:]` and `b_fused[j] = alpha_j * b[j] + beta_j`. Pass W_fused and b_fused into the existing fused_linear Triton kernel and feed its output directly to the softmax kernel (no BN, no extra scaling). Cache W_fused/b_fused and refresh them only when BN/scale parameters or BN running stats change to avoid recomputing each forward.

**Expected Speedup**: 20-30%

---

# Current Kernel (needs optimization)

```python
import torch
import torch.nn as nn
import triton
import triton.language as tl


# ---------------------------------------------
# GEMM (Linear) kernel: y = x @ W^T + b
# ---------------------------------------------
@triton.jit
def linear_forward_kernel(
    a_ptr, b_ptr, bias_ptr, c_ptr,
    M, N, K,
    stride_am, stride_ak,
    stride_bk, stride_bn,
    stride_cm, stride_cn,
    BLOCK_M: tl.constexpr, BLOCK_N: tl.constexpr, BLOCK_K: tl.constexpr,
):
    # Program IDs for 2D tile grid
    pid_m = tl.program_id(0)
    pid_n = tl.program_id(1)

    offs_m = pid_m * BLOCK_M + tl.arange(0, BLOCK_M)
    offs_n = pid_n * BLOCK_N + tl.arange(0, BLOCK_N)
    offs_k = tl.arange(0, BLOCK_K)

    # Pointers to the first tile of A and B
    a_ptrs = a_ptr + offs_m[:, None] * stride_am + offs_k[None, :] * stride_ak
    b_ptrs = b_ptr + offs_k[:, None] * stride_bk + offs_n[None, :] * stride_bn

    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)

    # Loop over K dimension
    for k in range(0, K, BLOCK_K):
        k_mask = offs_k[None, :] < (K - k)
        a = tl.load(
            a_ptrs,
            mask=(offs_m[:, None] < M) & k_mask,
            other=0.0,
        )
        b = tl.load(
            b_ptrs,
            mask=k_mask.T & (offs_n[None, :] < N),
            other=0.0,
        )
        acc += tl.dot(a, b, allow_tf32=True)
        a_ptrs += BLOCK_K * stride_ak
        b_ptrs += BLOCK_K * stride_bk

    # Add bias (broadcast over rows)
    bias = tl.load(bias_ptr + offs_n, mask=offs_n < N, other=0.0)
    acc += bias[None, :]

    # Write back
    c_ptrs = c_ptr + offs_m[:, None] * stride_cm + offs_n[None, :] * stride_cn
    mask = (offs_m[:, None] < M) & (offs_n[None, :] < N)
    tl.store(c_ptrs, acc, mask=mask)


def fused_linear(x: torch.Tensor, weight: torch.Tensor, bias: torch.Tensor) -> torch.Tensor:
    """
    High-performance replacement for:
        x = F.linear(x, weight, bias)  # (x @ weight.T + bias)

    Args:
        x:      [M, K]
        weight: [N, K]
        bias:   [N]
    Returns:
        y:      [M, N]
    """
    assert x.is_cuda and weight.is_cuda and bias.is_cuda
    x = x.contiguous()
    weight = weight.contiguous()
    bias = bias.contiguous()

    M, K = x.shape
    N = weight.shape[0]
    y = torch.empty((M, N), device=x.device, dtype=x.dtype)

    # Strides assuming row-major but kept generic
    stride_am, stride_ak = x.stride()
    # Interpret weight as B[k, n] == weight[n, k] via custom strides
    stride_bw0, stride_bw1 = weight.stride()  # (N, K) -> (K, 1)
    stride_bk = stride_bw1  # 1
    stride_bn = stride_bw0  # K
    stride_cm, stride_cn = y.stride()

    BLOCK_M = 128
    BLOCK_N = 128
    BLOCK_K = 32

    grid = lambda META: (
        triton.cdiv(M, META['BLOCK_M']),
        triton.cdiv(N, META['BLOCK_N']),
    )

    linear_forward_kernel[grid](
        x, weight, bias, y,
        M, N, K,
        stride_am, stride_ak,
        stride_bk, stride_bn,
        stride_cm, stride_cn,
        BLOCK_M=BLOCK_M, BLOCK_N=BLOCK_N, BLOCK_K=BLOCK_K,
        num_warps=8,
        num_stages=2,
    )
    return y


# ---------------------------------------------
# Fused scale + softmax over dim=1
# y[i, j] = softmax_j(scale * x[i, j])
# ---------------------------------------------
@triton.jit
def fused_scale_softmax_kernel(
    x_ptr, y_ptr,
    scale,
    M, N,
    stride_xm, stride_xn,
    stride_ym, stride_yn,
    BLOCK_SIZE: tl.constexpr,
):
    pid = tl.program_id(0)
    row = pid

    offs = tl.arange(0, BLOCK_SIZE)
    row_mask = row < M

    # 1) Compute row-wise max of scaled values for numerical stability
    row_max = -float('inf')
    for start_n in range(0, N, BLOCK_SIZE):
        cols = start_n + offs
        mask = (cols < N) & row_mask
        x_ptrs = x_ptr + row * stride_xm + cols * stride_xn
        x = tl.load(x_ptrs, mask=mask, other=0.0)
        x = x * scale
        x = tl.where(mask, x, -float('inf'))
        block_max = tl.max(x, axis=0)
        row_max = tl.maximum(row_max, block_max)

    # 2) Compute denominator: sum(exp(x - row_max))
    row_sum = 0.0
    for start_n in range(0, N, BLOCK_SIZE):
        cols = start_n + offs
        mask = (cols < N) & row_mask
        x_ptrs = x_ptr + row * stride_xm + cols * stride_xn
        x = tl.load(x_ptrs, mask=mask, other=0.0)
        x = x * scale
        x = tl.where(mask, x, -float('inf'))
        exp_x = tl.exp(x - row_max)
        block_sum = tl.sum(exp_x, axis=0)
        row_sum += block_sum

    # 3) Write normalized probabilities
    inv_row_sum = 1.0 / row_sum
    for start_n in range(0, N, BLOCK_SIZE):
        cols = start_n + offs
        mask = (cols < N) & row_mask
        x_ptrs = x_ptr + row * stride_xm + cols * stride_xn
        y_ptrs = y_ptr + row * stride_ym + cols * stride_yn
        x = tl.load(x_ptrs, mask=mask, other=0.0)
        x = x * scale
        x = tl.where(mask, x, -float('inf'))
        exp_x = tl.exp(x - row_max)
        y = exp_x * inv_row_sum
        tl.store(y_ptrs, y, mask=mask)


def fused_scale_softmax(x: torch.Tensor, scale_param: torch.Tensor) -> torch.Tensor:
    """
    High-performance replacement for:
        x = scale * x
        x = softmax(x, dim=1)

    Args:
        x:           [M, N]
        scale_param: scalar tensor (shape (1,) or broadcastable to x)
    Returns:
        y:           [M, N]
    """
    assert x.is_cuda and scale_param.is_cuda
    x = x.contiguous()
    M, N = x.shape
    y = torch.empty_like(x)

    # Use scalar scale for best performance
    scale = float(scale_param.item())

    stride_xm, stride_xn = x.stride()
    stride_ym, stride_yn = y.stride()

    BLOCK_SIZE = 128
    grid = lambda META: (triton.cdiv(M, 1),)

    fused_scale_softmax_kernel[grid](
        x, y,
        scale,
        M, N,
        stride_xm, stride_xn,
        stride_ym, stride_yn,
        BLOCK_SIZE=BLOCK_SIZE,
        num_warps=4,
        num_stages=2,
    )
    return y


# ---------------------------------------------
# Model with Triton-accelerated Linear + scale*Softmax
# BatchNorm is kept as in PyTorch to preserve training semantics
# ---------------------------------------------
class ModelNew(nn.Module):
    def __init__(self, in_features, out_features, bn_eps=1e-5, bn_momentum=0.1, scale_shape=(1,)):
        super(ModelNew, self).__init__()
        # Keep module structure/parameter names for easy state_dict loading
        self.gemm = nn.Linear(in_features, out_features)
        self.bn = nn.BatchNorm1d(out_features, eps=bn_eps, momentum=bn_momentum)
        self.scale = nn.Parameter(torch.ones(scale_shape))

    def forward(self, x):
        # Expect x to be on CUDA for Triton kernels
        x = fused_linear(x, self.gemm.weight, self.gemm.bias)
        x = self.bn(x)
        x = fused_scale_softmax(x, self.scale)
        return x
```

---

# Your Task

Implement the optimization strategy above. Focus on the specific bottleneck identified.

## Key Requirements

1. **Preserve correctness**: Maintain the same input/output behavior
2. **Apply the optimization**: Follow the implementation plan exactly
3. **Use valid Triton syntax**:
   - Every kernel MUST have `@triton.jit` decorator
   - Grid size MUST be > 0: use `triton.cdiv(N, BLOCK)` or `max(1, N // BLOCK)`
   - BLOCK sizes MUST be power-of-2: 16, 32, 64, 128, 256
   - No `continue`, `break`, `return` inside kernels (use masking)
   - Prefer `tl.dot(a, b, allow_tf32=True)` for matmul operations

4. **CRITICAL for RNN/GRU/LSTM Persistent Kernels**:
   - Time loop MUST be inside @triton.jit kernel, NOT in Python forward()
   - **HYBRID computation strategy** (CRITICAL for performance):
     * Precompute input-side gates OUTSIDE kernel: `gates_x = (T*B, In) @ W_ih` (ONE large GEMM)
     * INSIDE kernel: only recurrent-side: `for t: gates_h = h @ W_hh` (T small GEMMs)
   - CORRECT (FAST - use this):
     ```python
     # Python forward():
     gates_x_all = x.reshape(T*B, In) @ W_ih + b_ih  # ONE large GEMM
     gates_x_all = gates_x_all.view(T, B, 3*H)
     gru_persistent_kernel[grid](gates_x_all, h0, W_hh, ...)  # Launch ONCE

     @triton.jit
     def gru_persistent_kernel(gates_x_ptr, h_ptr, W_hh_ptr, ...):
         for t in range(T):  # Inside kernel
             gates_x_t = tl.load(gates_x_ptr + t*...)  # Precomputed
             gates_h = h @ W_hh  # Only recurrent GEMM
             h = (1-z)*n + z*h   # Fuse and update
     ```

5. **Output format**:
   - Imports: `import torch, torch.nn as nn, triton, triton.language as tl`
   - `@triton.jit` kernel(s)
   - Wrapper function(s)
   - `class ModelNew(nn.Module)` â€” REQUIRED
   - NO testing code, NO `if __name__ == "__main__"`

---

Generate the optimized kernel now. Output ONLY the complete Python code.
