```python
import torch
import torch.nn as nn
import triton
import triton.language as tl


@triton.autotune(
    configs=[
        # Baseline, conservative
        triton.Config(
            {
                "BLOCK_M": 32,
                "BLOCK_N": 32,
                "BLOCK_K": 32,
            },
            num_warps=4,
            num_stages=2,
        ),
        # Wider M-tile for better reuse over positions
        triton.Config(
            {
                "BLOCK_M": 64,
                "BLOCK_N": 32,
                "BLOCK_K": 32,
            },
            num_warps=8,
            num_stages=2,
        ),
        # Wider N and deeper K for large channel counts
        triton.Config(
            {
                "BLOCK_M": 32,
                "BLOCK_N": 64,
                "BLOCK_K": 64,
            },
            num_warps=8,
            num_stages=3,
        ),
    ],
    key=["N", "C_in", "D_out", "H_out", "W_out"],
)
@triton.jit
def conv_transpose3d_gemm_kernel(
    x_ptr,  # (N, C_in, D_in, H_in, W_in)
    w_ptr,  # (C_in, C_out_per_group, K_D, K_H, K_W)
    b_ptr,  # (C_out,) or dummy if HAS_BIAS=False
    y_ptr,  # (N, C_out, D_out, H_out, W_out)
    N, C_in, D_in, H_in, W_in,
    C_out, D_out, H_out, W_out,
    total_pos,             # N * D_out * H_out * W_out
    C_OUT_PER_GROUP: tl.constexpr,
    C_IN_PER_GROUP: tl.constexpr,
    K_D: tl.constexpr,
    K_H: tl.constexpr,
    K_W: tl.constexpr,
    STRIDE_D: tl.constexpr,
    STRIDE_H: tl.constexpr,
    STRIDE_W: tl.constexpr,
    PAD_D: tl.constexpr,
    PAD_H: tl.constexpr,
    PAD_W: tl.constexpr,
    GROUPS: tl.constexpr,
    HAS_BIAS: tl.constexpr,
    BLOCK_M: tl.constexpr,
    BLOCK_N: tl.constexpr,
    BLOCK_K: tl.constexpr,
):
    # ----------------------------------------------------------------------
    # Program IDs / grid layout
    # ----------------------------------------------------------------------
    pid_co = tl.program_id(axis=0)  # over (groups, output-channel tiles)
    pid_y = tl.program_id(axis=1)   # over M-blocks (positions) - fast axis
    pid_z = tl.program_id(axis=2)   # over M-blocks - slow axis

    # Number of program instances along each axis
    num_pid_co = tl.num_programs(axis=0)
    num_pid_y = tl.num_programs(axis=1)
    # num_pid_z = tl.num_programs(axis=2)  # not directly needed

    # Decode group and output-channel tile within group
    NUM_CO_BLOCKS_PER_GROUP = num_pid_co // GROUPS
    group_id = pid_co // NUM_CO_BLOCKS_PER_GROUP
    co_block_in_group = pid_co % NUM_CO_BLOCKS_PER_GROUP

    # Output-channel indices this program computes
    co_offsets = co_block_in_group * BLOCK_N + tl.arange(0, BLOCK_N)
    co_offsets = co_offsets + group_id * C_OUT_PER_GROUP
    mask_co = co_offsets < C_out

    # Global M-block id (over all positions)
    m_blocks_stride_y = num_pid_y
    m_block_id = pid_z * m_blocks_stride_y + pid_y

    off_m = tl.arange(0, BLOCK_M)
    pos = m_block_id * BLOCK_M + off_m  # flattened output positions
    mask_pos = pos < total_pos

    # ----------------------------------------------------------------------
    # Decode flattened output position -> (n, d_out, h_out, w_out)
    # ----------------------------------------------------------------------
    W_out_i = W_out
    H_out_i = H_out
    D_out_i = D_out

    w_out = pos % W_out_i
    tmp = pos // W_out_i
    h_out = tmp % H_out_i
    tmp = tmp // H_out_i
    d_out = tmp % D_out_i
    n = tmp // D_out_i

    # Cast to int32 for index arithmetic
    n = n.to(tl.int32)
    d_out = d_out.to(tl.int32)
    h_out = h_out.to(tl.int32)
    w_out = w_out.to(tl.int32)

    # ----------------------------------------------------------------------
    # Accumulator
    # ----------------------------------------------------------------------
    acc = tl.zeros((BLOCK_M, BLOCK_N), dtype=tl.float32)

    # Optional bias: add once per output-channel column
    if HAS_BIAS:
        bias_vals = tl.load(b_ptr + co_offsets, mask=mask_co, other=0.0)
        acc += bias_vals[None, :]

    # ----------------------------------------------------------------------
    # K-dimension decomposition
    # ----------------------------------------------------------------------
    K_ELEMS = K_D * K_H * K_W
    K_TOTAL = C_IN_PER_GROUP * K_ELEMS

    # Precompute some broadcasted output indices
    n_mat = n[:, None]          # [BLOCK_M, 1]
    d_out_mat = d_out[:, None]
    h_out_mat = h_out[:, None]
    w_out_mat = w_out[:, None]
    mask_pos_mat = mask_pos[:, None]

    # Output-channel locals within group
    co_local = co_offsets - group_id * C_OUT_PER_GROUP
    co_local_mat = co_local[None, :]  # [1, BLOCK_N]

    # ----------------------------------------------------------------------
    # Main loop over K dimension
    # ----------------------------------------------------------------------
    for k_start in range(0, K_TOTAL, BLOCK_K):
        k_idx = k_start + tl.arange(0, BLOCK_K)
        mask_k = k_idx < K_TOTAL

        # Decompose k_idx -> (ci_local, kd, kh, kw)
        ci_local = k_idx // K_ELEMS
        rem = k_idx % K_ELEMS
        kd = rem // (K_H * K_W)
        rem2 = rem % (K_H * K_W)
        kh = rem2 // K_W
        kw = rem2 % K_W

        # Global input channel indices for this group
        ci_global = group_id * C_IN_PER_GROUP + ci_local

        # Broadcast K-dim components
        kd_row = kd[None, :]          # [1, BLOCK_K]
        kh_row = kh[None, :]
        kw_row = kw[None, :]
        ci_global_row = ci_global[None, :]
        mask_k_row = mask_k[None, :]

        # Compute input spatial indices for each (M, K) pair
        num_d = d_out_mat + PAD_D - kd_row
        num_h = h_out_mat + PAD_H - kh_row
        num_w = w_out_mat + PAD_W - kw_row

        # Masks for valid mapping back to input indices (stride & bounds)
        mask_d = (num_d >= 0) & (num_d < STRIDE_D * D_in) & (num_d % STRIDE_D == 0)
        mask_h = (num_h >= 0) & (num_h < STRIDE_H * H_in) & (num_h % STRIDE_H == 0)
        mask_w = (num_w >= 0) & (num_w < STRIDE_W * W_in) & (num_w % STRIDE_W == 0)

        d_in = num_d // STRIDE_D
        h_in = num_h // STRIDE_H
        w_in = num_w // STRIDE_W

        # Bounds checks on input indices
        mask_d = mask_d & (d_in >= 0) & (d_in < D_in)
        mask_h = mask_h & (h_in >= 0) & (h_in < H_in)
        mask_w = mask_w & (w_in >= 0) & (w_in < W_in)

        # Final mask for input loads
        mask_in = mask_pos_mat & mask_d & mask_h & mask_w & mask_k_row

        # Compute flattened input indices
        ci_global_mat = ci_global_row  # [1, BLOCK_K]
        n_expand = n_mat               # [BLOCK_M, 1]

        x_index = n_expand * C_in
        x_index = x_index + ci_global_mat
        x_index = x_index * D_in + d_in
        x_index = x_index * H_in + h_in
        x_index = x_index * W_in + w_in

        x_vals = tl.load(x_ptr + x_index, mask=mask_in, other=0.0)
        x_vals = x_vals.to(tl.float32)  # [BLOCK_M, BLOCK_K]

        # Load weight tile W[K, N] for this group and co-tile
        ci_global_col = ci_global[:, None]  # [BLOCK_K, 1]
        kd_col = kd[:, None]
        kh_col = kh[:, None]
        kw_col = kw[:, None]

        w_index = ci_global_col * C_OUT_PER_GROUP + co_local_mat
        w_index = w_index * K_D + kd_col
        w_index = w_index * K_H + kh_col
        w_index = w_index * K_W + kw_col

        mask_wgt = mask_k[:, None] & mask_co[None, :]

        w_vals = tl.load(w_ptr + w_index, mask=mask_wgt, other=0.0)
        w_vals = w_vals.to(tl.float32)  # [BLOCK_K, BLOCK_N]

        # Matrix multiply: [BLOCK_M, BLOCK_K] @ [BLOCK_K, BLOCK_N]
        acc += tl.dot(x_vals, w_vals, allow_tf32=True)

    # ----------------------------------------------------------------------
    # Store results
    # ----------------------------------------------------------------------
    co_mat = co_offsets[None, :]  # [1, BLOCK_N]

    y_index = n_mat * C_out
    y_index = y_index + co_mat
    y_index = y_index * D_out + d_out_mat
    y_index = y_index * H_out + h_out_mat
    y_index = y_index * W_out + w_out_mat

    mask_out = mask_pos_mat & mask_co[None, :]

    tl.store(y_ptr + y_index, acc, mask=mask_out)


def triton_conv_transpose3d(
    x: torch.Tensor,
    weight: torch.Tensor,
    bias: torch.Tensor | None,
    stride: int,
    padding: int,
    output_padding: int,
    groups: int,
) -> torch.Tensor:
    # Ensure contiguity
    x = x.contiguous()
    weight = weight.contiguous()
    if bias is not None:
        bias = bias.contiguous()

    N, C_in, D_in, H_in, W_in = x.shape
    C_in_w, C_out_per_group, K_D, K_H, K_W = weight.shape
    assert C_in_w == C_in
    assert K_D == K_H == K_W

    C_out = C_out_per_group * groups

    stride_d = stride_h = stride_w = stride
    pad_d = pad_h = pad_w = padding

    # Output size (matches PyTorch's ConvTranspose3d for isotropic case)
    D_out = (D_in - 1) * stride_d - 2 * pad_d + K_D + output_padding
    H_out = (H_in - 1) * stride_h - 2 * pad_h + K_H + output_padding
    W_out = (W_in - 1) * stride_w - 2 * pad_w + K_W + output_padding

    # Allocate output
    y = torch.empty(
        (N, C_out, D_out, H_out, W_out),
        device=x.device,
        dtype=x.dtype,
    )

    # Early exit for degenerate cases (avoid 0-sized grid launches)
    if (
        N == 0
        or C_out == 0
        or D_out <= 0
        or H_out <= 0
        or W_out <= 0
    ):
        return y

    C_OUT_PER_GROUP = C_out_per_group
    C_IN_PER_GROUP = C_in // groups

    total_pos = N * D_out * H_out * W_out

    MAX_GRID_AXIS_YZ = 65535

    # Grid function depends on meta-parameters (BLOCK_M/BLOCK_N) for autotune
    def grid(meta):
        BLOCK_M = meta["BLOCK_M"]
        BLOCK_N = meta["BLOCK_N"]

        total_m_blocks = triton.cdiv(total_pos, BLOCK_M)
        grid_y = min(total_m_blocks, MAX_GRID_AXIS_YZ)
        grid_z = triton.cdiv(total_m_blocks, grid_y)

        num_co_blocks_per_group = triton.cdiv(C_OUT_PER_GROUP, BLOCK_N)
        grid_x = num_co_blocks_per_group * groups

        # Ensure all dimensions are > 0
        return (
            max(1, grid_x),
            max(1, grid_y),
            max(1, grid_z),
        )

    conv_transpose3d_gemm_kernel[grid](
        x,
        weight,
        bias if bias is not None else x,  # dummy when HAS_BIAS=False
        y,
        N,
        C_in,
        D_in,
        H_in,
        W_in,
        C_out,
        D_out,
        H_out,
        W_out,
        total_pos,
        C_OUT_PER_GROUP=C_OUT_PER_GROUP,
        C_IN_PER_GROUP=C_IN_PER_GROUP,
        K_D=K_D,
        K_H=K_H,
        K_W=K_W,
        STRIDE_D=stride_d,
        STRIDE_H=stride_h,
        STRIDE_W=stride_w,
        PAD_D=pad_d,
        PAD_H=pad_h,
        PAD_W=pad_w,
        GROUPS=groups,
        HAS_BIAS=bias is not None,
    )

    return y


class ModelNew(nn.Module):
    """
    Triton-optimized 3D transposed convolution (ConvTranspose3d) with
    GEMM-style tiling and implicit im2col, specialized for high throughput
    on modern GPUs (e.g., RTX 4090).
    """

    def __init__(
        self,
        in_channels: int,
        out_channels: int,
        kernel_size: int,
        stride: int = 1,
        padding: int = 0,
        output_padding: int = 0,
        groups: int = 1,
        bias: bool = False,
    ):
        super().__init__()

        # Initialize weights using PyTorch's ConvTranspose3d initializer
        ref = nn.ConvTranspose3d(
            in_channels,
            out_channels,
            kernel_size=(kernel_size, kernel_size, kernel_size),
            stride=stride,
            padding=padding,
            output_padding=output_padding,
            groups=groups,
            bias=bias,
        )
        self.weight = nn.Parameter(ref.weight.detach())
        if bias:
            self.bias = nn.Parameter(ref.bias.detach())
        else:
            self.bias = None

        self.in_channels = in_channels
        self.out_channels = out_channels
        self.kernel_size = kernel_size
        self.stride = stride
        self.padding = padding
        self.output_padding = output_padding
        self.groups = groups

    def forward(self, x: torch.Tensor) -> torch.Tensor:
        return triton_conv_transpose3d(
            x,
            self.weight,
            self.bias,
            stride=self.stride,
            padding=self.padding,
            output_padding=self.output_padding,
            groups=self.groups,
        )
```