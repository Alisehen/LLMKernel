```python
# <complete ModelNew code with optimized Triton kernels>
import torch
import torch.nn as nn
import triton
import triton.language as tl


# -----------------------------
# Triton kernel: softmax over last dimension
# -----------------------------
@triton.autotune(
    configs=[
        triton.Config({'BLOCK_N': 128}, num_warps=4),
        triton.Config({'BLOCK_N': 256}, num_warps=8),
    ],
    key=['N'],
)
@triton.jit
def softmax_lastdim_kernel(
    x_ptr, y_ptr,
    M, N,
    stride_xm, stride_xn,
    stride_ym, stride_yn,
    BLOCK_N: tl.constexpr,
):
    """
    Computes softmax along the last dimension for a 2D tensor of shape (M, N).
    Each program instance handles one row (length N).

    x_ptr, y_ptr: pointers to input/output
    M: number of rows
    N: number of columns (softmax dimension)
    stride_*: row/col strides
    """
    m = tl.program_id(0)
    # Base pointers for this row
    x_row_ptr = x_ptr + m * stride_xm
    y_row_ptr = y_ptr + m * stride_ym

    # Offsets within a block along N
    offs = tl.arange(0, BLOCK_N)

    # -------------------------
    # Pass 1: compute row-wise max for numerical stability
    # -------------------------
    # First block initializes the maximum
    mask = offs < N
    x = tl.load(x_row_ptr + offs * stride_xn, mask=mask, other=-float('inf'))
    row_max = tl.max(x, axis=0)

    # Remaining blocks update the maximum
    for start_n in range(BLOCK_N, N, BLOCK_N):
        offs_block = start_n + offs
        mask = offs_block < N
        x = tl.load(x_row_ptr + offs_block * stride_xn, mask=mask, other=-float('inf'))
        curr_max = tl.max(x, axis=0)
        row_max = tl.maximum(row_max, curr_max)

    # -------------------------
    # Pass 2: compute exp(x - max) and row-wise sum(exp)
    #         Store exp(...) temporarily in y_ptr
    # -------------------------
    # First block initializes the sum
    offs = tl.arange(0, BLOCK_N)
    mask = offs < N
    x = tl.load(x_row_ptr + offs * stride_xn, mask=mask, other=-float('inf'))
    exp_x = tl.exp(x - row_max)
    row_sum = tl.sum(exp_x, axis=0)
    tl.store(y_row_ptr + offs * stride_yn, exp_x, mask=mask)

    # Remaining blocks accumulate the sum
    for start_n in range(BLOCK_N, N, BLOCK_N):
        offs_block = start_n + offs
        mask = offs_block < N
        x = tl.load(x_row_ptr + offs_block * stride_xn, mask=mask, other=-float('inf'))
        exp_x = tl.exp(x - row_max)
        row_sum = row_sum + tl.sum(exp_x, axis=0)
        tl.store(y_row_ptr + offs_block * stride_yn, exp_x, mask=mask)

    # -------------------------
    # Pass 3: normalize stored exp values by row_sum
    # -------------------------
    offs = tl.arange(0, BLOCK_N)
    # First block
    mask = offs < N
    exp_x = tl.load(y_row_ptr + offs * stride_yn, mask=mask, other=0.0)
    softmax_x = exp_x / row_sum
    tl.store(y_row_ptr + offs * stride_yn, softmax_x, mask=mask)

    # Remaining blocks
    for start_n in range(BLOCK_N, N, BLOCK_N):
        offs_block = start_n + offs
        mask = offs_block < N
        exp_x = tl.load(y_row_ptr + offs_block * stride_yn, mask=mask, other=0.0)
        softmax_x = exp_x / row_sum
        tl.store(y_row_ptr + offs_block * stride_yn, softmax_x, mask=mask)


def triton_softmax_lastdim(x: torch.Tensor) -> torch.Tensor:
    """
    Softmax over the last dimension of x using Triton.
    x: (..., W)
    Returns tensor with same shape and dtype as x.
    """
    if x.numel() == 0:
        return x

    orig_dtype = x.dtype
    x_f = x.float().contiguous()  # compute in float32 for numerical stability

    last_dim = x_f.shape[-1]
    x_2d = x_f.view(-1, last_dim)
    M, N = x_2d.shape

    y_2d = torch.empty_like(x_2d)

    grid = lambda META: (M,)

    softmax_lastdim_kernel[grid](
        x_2d, y_2d,
        M, N,
        x_2d.stride(0), x_2d.stride(1),
        y_2d.stride(0), y_2d.stride(1),
    )

    y = y_2d.view_as(x_f)
    if orig_dtype != torch.float32:
        y = y.to(orig_dtype)
    return y


# -----------------------------
# Network components
# -----------------------------
class DoubleConv(nn.Module):
    """
    Two consecutive Conv2d + BatchNorm2d + Softmax(dim=-1),
    with Softmax implemented via a Triton kernel.
    """
    def __init__(self, in_channels, out_channels):
        super().__init__()
        self.conv1 = nn.Conv2d(in_channels, out_channels, kernel_size=3, padding=1)
        self.bn1 = nn.BatchNorm2d(out_channels)
        self.conv2 = nn.Conv2d(out_channels, out_channels, kernel_size=3, padding=1)
        self.bn2 = nn.BatchNorm2d(out_channels)

    def forward(self, x):
        # First conv block
        x = self.conv1(x)
        x = self.bn1(x)
        x = triton_softmax_lastdim(x)  # softmax over width (last dim)

        # Second conv block
        x = self.conv2(x)
        x = self.bn2(x)
        x = triton_softmax_lastdim(x)  # softmax over width (last dim)
        return x


class ModelNew(nn.Module):
    def __init__(self, in_channels, out_channels, features):
        """
        U-Net-like model with Triton-accelerated Softmax in DoubleConv blocks.
        :param in_channels: Number of input channels
        :param out_channels: Number of output channels
        :param features: Number of base features (doubled in each encoder layer)
        """
        super(ModelNew, self).__init__()
        self.encoder1 = DoubleConv(in_channels, features)
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)
        self.encoder2 = DoubleConv(features, features * 2)
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)
        self.encoder3 = DoubleConv(features * 2, features * 4)
        self.pool3 = nn.MaxPool2d(kernel_size=2, stride=2)
        self.encoder4 = DoubleConv(features * 4, features * 8)
        self.pool4 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.bottleneck = DoubleConv(features * 8, features * 16)

        self.upconv4 = nn.ConvTranspose2d(features * 16, features * 8, kernel_size=2, stride=2)
        self.decoder4 = DoubleConv(features * 16, features * 8)

        self.upconv3 = nn.ConvTranspose2d(features * 8, features * 4, kernel_size=2, stride=2)
        self.decoder3 = DoubleConv(features * 8, features * 4)

        self.upconv2 = nn.ConvTranspose2d(features * 4, features * 2, kernel_size=2, stride=2)
        self.decoder2 = DoubleConv(features * 4, features * 2)

        self.upconv1 = nn.ConvTranspose2d(features * 2, features, kernel_size=2, stride=2)
        self.decoder1 = DoubleConv(features * 2, features)

        self.final_conv = nn.Conv2d(features, out_channels, kernel_size=1)

    def forward(self, x):
        """
        :param x: Input tensor, shape (batch_size, in_channels, height, width)
        :return: Output tensor, shape (batch_size, out_channels, height, width)
        """
        # Encoder
        enc1 = self.encoder1(x)
        enc2 = self.encoder2(self.pool1(enc1))
        enc3 = self.encoder3(self.pool2(enc2))
        enc4 = self.encoder4(self.pool3(enc3))

        # Bottleneck
        bottleneck = self.bottleneck(self.pool4(enc4))

        # Decoder
        dec4 = self.upconv4(bottleneck)
        dec4 = torch.cat((dec4, enc4), dim=1)
        dec4 = self.decoder4(dec4)

        dec3 = self.upconv3(dec4)
        dec3 = torch.cat((dec3, enc3), dim=1)
        dec3 = self.decoder3(dec3)

        dec2 = self.upconv2(dec3)
        dec2 = torch.cat((dec2, enc2), dim=1)
        dec2 = self.decoder2(dec2)

        dec1 = self.upconv1(dec2)
        dec1 = torch.cat((dec1, enc1), dim=1)
        dec1 = self.decoder1(dec1)

        return self.final_conv(dec1)
```